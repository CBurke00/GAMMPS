#!/usr/bin/env python
# coding: utf-8

'''
This is the first code to run in Step 1.
This code generates the oligomer structures (in xyz format) from the monomer sequence given in parameters.py 
and the input xyz files given in the "fragments" folder which should be provided alongside the code (see Examples).
It also generates Gaussian input files for all possible relative cis/trans conformers and 
submits the Gaussian calculations to find the conformer with the minimum potential energy for the next step.

'''

import numpy as np
import subprocess
import math
import random
import os
import copy as cp
import itertools
from scipy.spatial.transform import Rotation as R
import time
start = time.time()

from parameters import *

path_fragments=cp.deepcopy(PATH_FRAGMENTS)
parent_dir=cp.deepcopy(PATH_OUTPUT)
moleculename = OLIGOMERNAME
path_output = os.path.join(parent_dir, moleculename)
theory=cp.deepcopy(THEORY)
if not os.path.exists(path_output):
    os.makedirs(path_output)

fiveringmembers=FIVERINGS#five rings should be treated differently
    
with open(path_output+'.log', "w") as f:
    f.write("\n;GENERATED BY GAMMPS\n;Troisi Lab @ University of Liverpool\n\n Step 1: Constructing oligomer coordinate and force field files\n")
with open(path_output+'.html', "w") as f:
    f.write('<!DOCTYPE html>\n<html>\n')
    f.write('<style>\naside.figures {\n    overflow: hidden; /* only needed if floating the child elements instead of using inline-block */\n}\n')
    f.write('\nfigcaption{\n  background-color: black;\n  color: white;\n  font-style: italic;\n  padding: 2px;\n  text-align: center;}\n')
    f.write('\naside.figures figure {\n    display: inline-block;\n    border: 1px solid;\n}\n</style>\n<body>\n')
    f.write('<basefont face = "arial" size = "2">')
    f.write('\n<p > ;GENERATED BY GAMMPS  ;Troisi Lab @ University of Liverpool  </p>')  
    f.write('\n<p><font size = "+2">\n Step 1: Constructing oligomer coordinate and force field files </font> </p>\n')
def rotate(origin, point, angle): #do the rotation in xy plane
    """
    Rotate a point counterclockwise by a given angle around a given origin.

    The angle should be given in radians.
    """
    ox, oy = origin
    px, py = point

    qx = ox + math.cos(angle) * (px - ox) - math.sin(angle) * (py - oy)
    qy = oy + math.sin(angle) * (px - ox) + math.cos(angle) * (py - oy)
    return qx, qy

def rotation_matrix_from_vectors(vector1, vector2):
    """ Find the rotation matrix that aligns vec1 to vec2
    :param vec1: A 3d "source" vector
    :param vec2: A 3d "destination" vector
    :return mat: A transform matrix (3x3) which when applied to vec1, aligns it with vec2.
    """
    a, b = (vector1 / np.linalg.norm(vector1)).reshape(3), (vector2 / np.linalg.norm(vector2)).reshape(3)
    v = np.cross(a, b)
    c = np.dot(a, b)
    s = np.linalg.norm(v)
    kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
    rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))
    return rotation_matrix

def rotation_matrix(vec_1, vec_2,theta): #find the rotation matrix for rotating vec_1 to be aligned with vec_2
    """
    Rotating the fragment around the axis connecting its connector beads, which is
    the first and the last atoms for the middle fragments
    """
    unit_vector = (vec_1-vec_2)/np.linalg.norm(vec_1-vec_2)
    rotation_mat=np.array([[math.cos(theta)+unit_vector[0]**2*(1-math.cos(theta)), unit_vector[0]*unit_vector[1]*(1-math.cos(theta))-unit_vector[2]*math.sin(theta), unit_vector[0]*unit_vector[2]*(1-math.cos(theta))+unit_vector[1]*math.sin(theta)], 
                       [unit_vector[1]*unit_vector[0]*(1-math.cos(theta))+unit_vector[2]*math.sin(theta), math.cos(theta)+unit_vector[1]**2*(1-math.cos(theta)), unit_vector[1]*unit_vector[2]*(1-math.cos(theta))-unit_vector[0]*math.sin(theta)], 
                       [unit_vector[2]*unit_vector[0]*(1-math.cos(theta))-unit_vector[1]*math.sin(theta), unit_vector[2]*unit_vector[1]*(1-math.cos(theta))+unit_vector[0]*math.sin(theta), math.cos(theta)+unit_vector[2]**2*(1-math.cos(theta))]])
    return rotation_mat


individual_fragments=cp.deepcopy(ALLFRAGMENTS)
individual_fragments_molecularmass=cp.deepcopy(ALLFRAGMENTS_MASS)
repeatunit_size=len(FRAGMENTLIST)
fragmentlist=cp.deepcopy(FRAGMENTLIST)
fragmentlist.insert(0,fragmentlist[-1]) # add capping fragments (to the first end) to make oligomer
fragmentlist.insert(len(fragmentlist),fragmentlist[1]) # add capping fragments (to the second end) to make oligomer

molecularweightofoligomer=0
for i in fragmentlist[1:-1]:
    molecularweightofoligomer+=individual_fragments_molecularmass[individual_fragments.index(i)]

angle = math.radians(124)#  finding the position of connecting carbon of fragment 2
dist0 = 1.5 # bond length between two fragments
rotate_z = 15 # degree of rotation around connecting carbon atoms in z direction to avoid clashing

with open(path_output+'.log', "a") as f:
    f.write("\nFragment sequence of oligomer is: "+str(fragmentlist)+"\n")
    f.write("\nMolecular weight of oligomer is: "+str(round(molecularweightofoligomer,2))+"\n")
    f.write("\nBond length between fragments is: "+str(dist0)+" Å\n")
with open(path_output+'.html', "a") as f:
    f.write("\nFragment sequence of oligomer is: "+str(fragmentlist)+"<br>\n")
    f.write("\nMolecular weight of oligomer is: "+str(round(molecularweightofoligomer,2))+"<br>\n")
    f.write("\nBond length between fragments is: "+str(dist0)+" Å<br><b>\n")
for j in range(1,len(fragmentlist)-1):
    with open(path_output+'/fragment.tcl', "w") as f:
        f.write("mol new ../../fragments/"+fragmentlist[j]+".xyz type {xyz}\n\nmol modstyle 0 0 CPK 1.000000 0.300000 120.000000 120.000000\n\nmol modcolor 0 0 Name\n\ndisplay resetview\n\naxes location Off\n\n")
        f.write("color Display Background white\n\ndisplay projection orthographic\n\n"+"render Tachyon "+path_output+"/"+fragmentlist[j]+" "+VMD_RENDER+" -aasamples 12 %s -format TARGA -o %s.tga -res 1000 1000"+"\nexit\n")
    subprocess.run(['vmd','-dispdev','text','-e', 'fragment.tcl'], cwd = path_output)
    subprocess.run(['magick', fragmentlist[j]+'.tga', fragmentlist[j]+'.jpeg'], cwd = path_output)
    
with open(path_output+'.html', "a") as f:
    f.write("\n<p> Backbone fragments are shown below </p>\n")
    f.write('<aside class="figures">\n')
    for j in range(1,len(fragmentlist)-1): 
        f.write('<figure>\n<img src="'+moleculename+'/'+fragmentlist[j]+'.jpeg" style="width: 300px; height: 200px; object-fit: cover;" alt="'+fragmentlist[j]+'">\n<figcaption>'+fragmentlist[j]+'</figcaption>\n</figure>')
    f.write('</aside>\n')
    f.write("\n<p> The LJ parameters of each fragment are provided in an .atp file in the <fragments> folder </p>\n")

#middle fragments    
combinations = list(itertools.product(["up", "down"], repeat=len(fragmentlist)-1))
combinations_list=[]
for i in range(len(combinations)):
    combinations_list.append(list(combinations[i]))
FRAGMENT={}
ATOMNAME={}
for count_flip, frag_flip in enumerate(combinations_list):
    coordinate1=[]
    atomname1=[]
    #first fragment
    with open(path_fragments+fragmentlist[0]+'.xyz') as f:
        coordlines=f.readlines()[2:-1] # remove the first two lines of xyz file and the last hydrogen (the one connecting to reacting carbon)
        for each in coordlines:
            coord=each.split()
            coordinate1.append([float(coord[1]),float(coord[2]),float(coord[3])])
            atomname1.append([coord[0]])
        vector=np.array(coordinate1[0])-np.array(coordinate1[-2])
        vector_unit=vector/np.linalg.norm(vector)
        rot_mat=rotation_matrix_from_vectors(np.array([-1.0, 0.0, 0.0]),vector_unit)#align the molecule towards x axis
        coordinate1numpy=np.matmul(coordinate1,rot_mat)
        #rotate along z direction arond the vector of two connecting carbons of each fragment
        rotation_radians = np.radians(-rotate_z)
        rotation_vector = rotation_radians * (coordinate1numpy[2]-coordinate1numpy[0])
        rotation = R.from_rotvec(rotation_vector)
        coordinate1numpy = rotation.apply(coordinate1numpy)
        # end ot rotate along z direction arond the vector of two connecting carbons of each fragment
        atomname1numpy=np.array(atomname1)
        coordinate1moved=coordinate1numpy-coordinate1numpy[0] # all coordinate move so that atom zero is at 0,0,0 for fragment 1
        coordinate1z=coordinate1moved[:,2:]
        coordinate1noz=coordinate1moved[:,:-1]
        origin=coordinate1noz[0]
        NEWPOINTS=[]
        for ang in range(0,360,5): #find the best rotation
            newpoints=[]
            for points in coordinate1noz:
                newpoint=rotate(origin, points, math.radians(ang))
                newpoints.append(newpoint)
            NEWPOINTS.append(newpoints)
        NEWPOINTSNUMPY=np.array(NEWPOINTS)
        SUM=[]
        for i in range(len(NEWPOINTSNUMPY)):
            SUM.append(np.sum(NEWPOINTSNUMPY[i][:,0]))
        bestrotation=NEWPOINTSNUMPY[SUM.index(min(SUM))]


        coordinate1finalnoz=bestrotation
        coordinate1final=np.append(coordinate1finalnoz, coordinate1z, axis=1)


        origin = coordinate1finalnoz[0]
        point = coordinate1finalnoz[0]+[dist0,0]
        NEWPOINTS=[]
        for ang in range(-90,90,5): #find the rotation with correct angle with respect to the connecting fragment
            newpoints=[]
            newpoint=rotate(origin, point, math.radians(ang))
            NEWPOINTS.append(newpoint)
        NEWPOINTSNUMPY=np.array(NEWPOINTS)
        DIFF=[]
        b = coordinate1final[0]
        b = np.array(b,dtype='float')
        a = coordinate1final[1]
        a = np.array(a,dtype='float')
        c = coordinate1final[2]
        c = np.array(c,dtype='float')
        for i in range(len(NEWPOINTSNUMPY)):
            d=np.append(NEWPOINTSNUMPY[i],0)
            d=np.array(d,dtype='float')
            ba = a - b
            bc = c - b
            bd = d - b
            cosine_angle1 = np.dot(ba, bd) / (np.linalg.norm(ba) * np.linalg.norm(bd))
            angle1 = np.arccos(cosine_angle1)
            cosine_angle2 = np.dot(bc, bd) / (np.linalg.norm(bc) * np.linalg.norm(bd))
            angle2 = np.arccos(cosine_angle2)
            diff=abs(angle1-angle2)
            DIFF.append(math.degrees(diff))
        fragment2pos=NEWPOINTSNUMPY[DIFF.index(min(DIFF))]
        fragment2posnumpy=np.array(fragment2pos)
        fragment2posfinal=np.append(fragment2posnumpy, coordinate1final[0][2])
    # second fragment on....
    fragment={}
    atomname={}
    fragment[0]=coordinate1final
    atomname[0]=atomname1numpy
    TEST=[]
    for count, frag in enumerate(fragmentlist[1:]):
        #rotate the whole molecule towards x axis
        vector=fragment[0][len(fragment[0])-1]-fragment[count][0]
        vector_unit=vector/np.linalg.norm(vector)
        rot_mat=rotation_matrix_from_vectors(np.array([-1.0, 0.0, 0.0]),vector_unit)#align the molecule towards x axis
        for member_count in range(count+1):
            fragment[member_count]=np.matmul(fragment[member_count],rot_mat)
        fragment2posfinal=np.matmul(fragment2posfinal,rot_mat)
        #end of rotate the whole molecule towards x axis
        NEWPOINTSNUMPY=[]
        bestrotation =[]
        coordinate2=[]
        atomname2=[]
        with open(path_fragments+frag+'.xyz') as f:
            coordlines=f.readlines()[2:-2] # remove the first two lines of xyz file and the last hydrogen (the one connecting to reacting carbon)
        with open(path_fragments+frag+'.xyz') as f:
            coordlines_temp=f.readlines()[-1]
            coordlines.append(coordlines_temp)
            for each in coordlines:
                coord=each.split()
                coordinate2.append([float(coord[1]),float(coord[2]),float(coord[3])])
                atomname2.append([coord[0]])
            vector=np.array(coordinate2[0])-np.array(coordinate2[-1])#align the fragment towards x axis
            vector_unit=vector/np.linalg.norm(vector)
            rot_mat=rotation_matrix_from_vectors(np.array([-1.0, 0.0, 0.0]),vector_unit)
            coordinate2numpy=np.matmul(coordinate2,rot_mat)#end of align the fragment towards x axis
            #rotate along z direction arond the vector of two connecting carbons of each fragment
            if (count%2==0):
                rotation_radians = np.radians(rotate_z)
            else:
                rotation_radians = np.radians(-rotate_z)
            
            rotation_vector = rotation_radians * (coordinate2numpy[0]-coordinate2numpy[-1])
            rotation = R.from_rotvec(rotation_vector)
            coordinate2numpy = rotation.apply(coordinate2numpy)
            # end ot rotate along z direction arond the vector of two connecting carbons of each fragment
            atomname2numpy=np.array(atomname2)
            coordinate2moved=coordinate2numpy-(coordinate2numpy[-2]-fragment2posfinal) # all coordinate move so that atom n-2 is at fragment2pos
            coordinate2z=coordinate2moved[:,2:]
            coordinate2noz=coordinate2moved[:,:-1]
           
            if (combinations_list[count_flip][count]=='down'):
                coordinate2complete=np.append(coordinate2noz, coordinate2z, axis=1)
                flip_matrix=rotation_matrix(coordinate2complete[0], coordinate2complete[-2], math.radians(180))
                fragment_flip=[]
                for atoms in range(len(coordinate2complete)):
                    move_atom_to_zero = coordinate2complete[atoms]-coordinate2complete[0]
                    moved_atom_flip = np.matmul(move_atom_to_zero,flip_matrix)
                    move_flipped_atom_back = moved_atom_flip+coordinate2complete[0]
                    fragment_flip.append(move_flipped_atom_back)
                coordinate2noz=np.delete(fragment_flip,-1,1)
             
            origin=coordinate2noz[-2]
            NEWPOINTS=[]
            for ang in range(0,360,5): #find the best rotation
                newpoints=[]
                for points in coordinate2noz:
                    newpoint=rotate(origin, points, math.radians(ang))
                    newpoints.append(newpoint)
                NEWPOINTS.append(newpoints)
            NEWPOINTSNUMPY=np.array(NEWPOINTS)
            first=[]
            second=[]
            SUM=[]
            for i in range(len(NEWPOINTSNUMPY)):
                first.append(np.linalg.norm(NEWPOINTSNUMPY[i][-3]-fragment[count][0][:-1]))
                second.append(np.linalg.norm(NEWPOINTSNUMPY[i][-4]-fragment[count][0][:-1]))
                SUM.append(np.sum(first[i]+second[i]))
            bestrotation=NEWPOINTSNUMPY[SUM.index(max(SUM))]

            NEWPOINTS=[]
            for ang in range(-90,90,5): #find the rotation with correct angle with respect to the connecting fragment
                newpoints=[]
                for points in bestrotation:
                    newpoint=rotate(origin, points, math.radians(ang))
                    newpoints.append(newpoint)
                NEWPOINTS.append(newpoints)
            NEWPOINTSNUMPY=np.array(NEWPOINTS)
            DIFF=[]
            a = fragment[count][0]
            a = np.array(a,dtype='float')
            for i in range(len(NEWPOINTSNUMPY)):
                b=np.append(NEWPOINTSNUMPY[i][-2],0)
                b=np.array(b,dtype='float')
                c=np.append(NEWPOINTSNUMPY[i][-3],0)
                c=np.array(c,dtype='float')
                if (frag in fiveringmembers):
                    d=np.append(NEWPOINTSNUMPY[i][2],0)
                    d=np.array(d,dtype='float')
                else:
                    d=np.append(NEWPOINTSNUMPY[i][-4],0)
                    d=np.array(d,dtype='float')
                ba = a - b
                bc = c - b
                bd = d - b
                cosine_angle1 = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
                angle1 = np.arccos(cosine_angle1)
                cosine_angle2 = np.dot(ba, bd) / (np.linalg.norm(ba) * np.linalg.norm(bd))
                angle2 = np.arccos(cosine_angle2)
                diff=abs(angle1-angle2)
                DIFF.append(math.degrees(diff))
            bestrotation=NEWPOINTSNUMPY[DIFF.index(min(DIFF))]

            coordinate2finalnoz=bestrotation
            coordinate2final=np.append(bestrotation, coordinate2z, axis=1)

        if (len(fragmentlist)>count+2): # prepare the connection to next fragment
            coordinate2final=np.delete(coordinate2final,-1, axis=0)
            atomname2numpy=np.delete(atomname2numpy,-1, axis=0)

            origin = coordinate2finalnoz[0]

            point= coordinate2finalnoz[0]+[dist0,0]

            NEWPOINTS=[]
            for ang in range(-90,90,1): #find the rotation with correct angle with respect to the connecting fragment
                newpoints=[]
                newpoint=rotate(origin, point, math.radians(ang))
                NEWPOINTS.append(newpoint)
            NEWPOINTSNUMPY=np.array(NEWPOINTS)
            DIFF=[]
            b = coordinate2final[0]
            b = np.array(b,dtype='float')
            a = coordinate2final[1]
            a = np.array(a,dtype='float')
            c = coordinate2final[2]
            c = np.array(c,dtype='float')
            for i in range(len(NEWPOINTSNUMPY)):
                d=np.append(NEWPOINTSNUMPY[i],0)
                d=np.array(d,dtype='float')
                ba = a - b
                bc = c - b
                bd = d - b
                cosine_angle1 = np.dot(ba, bd) / (np.linalg.norm(ba) * np.linalg.norm(bd))
                angle1 = np.arccos(cosine_angle1)
                cosine_angle2 = np.dot(bc, bd) / (np.linalg.norm(bc) * np.linalg.norm(bd))
                angle2 = np.arccos(cosine_angle2)
                diff=abs(angle1-angle2)
                DIFF.append(math.degrees(diff))
            fragment2pos=NEWPOINTSNUMPY[DIFF.index(min(DIFF))]
            fragment2posnumpy=np.array(fragment2pos)
            fragment2posfinal=np.append(fragment2posnumpy, coordinate2final[0][2])
        fragment[count+1]=coordinate2final
        atomname[count+1]=atomname2numpy
    FRAGMENT[count_flip]=fragment
    ATOMNAME[count_flip]=atomname


title=0
max_length=[]
for j in range(len(FRAGMENT)):
    title+=1
    totalnumberofatoms=0
    max_length.append(abs(FRAGMENT[j][len(fragmentlist)-1][-1][0]-FRAGMENT[j][0][0][0]))
    for i in range(len(FRAGMENT[j])):
        totalnumberofatoms+=len(FRAGMENT[j][i])
    with open(path_output+'/oligomer-'+str(title)+'.xyz', "w") as f:
        f.write(str(totalnumberofatoms)+"\n")
        f.write("\n")
        for i in range(len(FRAGMENT[j])):
            for k in range(len(FRAGMENT[j][i])):
                line = '{0:<8}'.format(ATOMNAME[j][i][k][0])+'{0:>12}'.format("{:.7f}".format(float(FRAGMENT[j][i][k][0])))+' '+'{0:>12}'.format("{:.7f}".format(float(FRAGMENT[j][i][k][1])))+' '+'{0:>12}'.format("{:.7f}".format(float(FRAGMENT[j][i][k][2])))
                f.write(line+"\n")
    with open(path_output+'/oligomer-'+str(title)+'.xyz', "r") as f:
        coordlines=f.readlines()[2:]
    with open(path_output+'/oligomer-'+str(title)+'.com', "w") as f:
        f.write("%nproc=10\n")
        f.write("%mem=9GB\n")
        f.write("%chk="+moleculename+str(j+1)+".chk\n")
        f.write("#p opt "+theory[0]+"\n\n")
        f.write("Gaussian optimization calculation on oligomer"+str(title)+"\n\n")
        f.write("0,1\n")
        f.writelines(coordlines)
        f.write("\n")
    
end = time.time()
with open(path_output+'.log', "a") as f:
    f.write("\nXYZ coordinate files and Gaussian optimization input files for "+str(title)+" oligomers are generated in "+moleculename+" folder\n\nRuntime of this step was "+str(round(end - start,1))+" s\n")
    f.write("\nMaximum and minumum lengths of oligomers are: "+str(round(max(max_length),3))+" and "+ str(round(min(max_length),3))+" Angstrom, respectively.\n")

for j in range(len(FRAGMENT)):
    with open(path_output+'/oligomer.tcl', "w") as f:
        f.write("mol new oligomer-"+str(j+1)+".xyz type {xyz}\n\nmol modstyle 0 0 CPK 1.000000 0.300000 120.000000 120.000000\n\nmol modcolor 0 0 Name\n\ndisplay resetview\n\naxes location Off\n\n")
        f.write("color Display Background white\n\ndisplay projection orthographic\n\n"+"render Tachyon "+path_output+"/oligomer-"+str(j+1)+" "+VMD_RENDER+" -aasamples 12 %s -format TARGA -o %s.tga -res 1000 1000"+"\nexit\n")
    subprocess.run(['vmd','-dispdev','text','-e', 'oligomer.tcl'], cwd = path_output)
    subprocess.run(['magick', 'oligomer-'+str(j+1)+'.tga', 'oligomer-'+str(j+1)+'.jpeg'], cwd = path_output)
    
with open(path_output+'.html', "a") as f:
    f.write("\n<p>XYZ coordinate files and Gaussian optimization input files for "+str(title)+" oligomers are generated in "+moleculename+" folder\n\nRuntime of this step was "+str(round(end - start,1))+" s </p>\n")
    f.write("\n<p>The level of theory for this QM calculation is "+theory[0]+" </p>\n")
    f.write('<aside class="figures">\n')
    for j in range(len(FRAGMENT)): 
        f.write('<figure>\n<img src="'+moleculename+'/oligomer-'+str(j+1)+'.jpeg" style="width: 300px; height: 100px; object-fit: cover;" alt="oligomer-'+str(j+1)+'">\n<figcaption>oligomer-'+str(j+1)+'</figcaption>\n</figure>')
    f.write('</aside>\n')
    f.write("\n<p>Maximum and minumum lengths of oligomers are: "+str(round(max(max_length),3))+" and "+ str(round(min(max_length),3))+" Angstrom, respectively.</p>\n")

with open(path_output+'/edit.sh', 'w') as f:
    f.write("#!/bin/bash -l\n\n")
    f.write("for a in {0.."+str(title)+"}; do \n")
    f.write('sed -i "s/oligomer-[0-9]*/oligomer-${a}/g" run.sh\n')
    f.write('sed -i "s/opt-[0-9]*/opt-${a}/g" run.sh\n')
    f.write("sbatch run.sh\n")
    f.write("done \n\n")

with open(path_output+'/run.sh', 'w') as f:
    f.write("#!/bin/bash -l\n\n#SBATCH --job-name opt-1\n#SBATCH -p "+CPUNODE+"\n#SBATCH -N 1\n#SBATCH -n 10\n#SBATCH --time 0-24:00:00\n")
    f.write("module load apps/gaussian/16\n\n")
    f.write("g16 oligomer-16.com\n\n")
if (SUBMITJOB=='yes'):
    subprocess.run(['chmod','+x','edit.sh'], cwd = path_output)
    subprocess.run(['./edit.sh'], cwd = path_output)

